# -*- coding: utf-8 -*-
"""WaterJug.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19FqdYryHKfLa7xQ40YgafqPE73DOWahX

# Water Jug Problem using Search Algorithms
Objective:
Implement BFS, DFS, and A* search algorithms to solve the classic Water Jug Problem.
* Jug1 capacity = 4 liters
* Jug2 capacity = 3 liters
* Goal = Measure exactly 2 liters
1. Breadth-First Search (BFS)

 * BFS explores the state space level by level, starting from the initial state and expanding all possible next moves before going deeper.

* Guarantees shortest path.

* Uses more memory because it stores many states.

* Best for: when shortest path is required and problem size is small to medium.
"""

from collections import deque

JUG1 = 4
JUG2 = 3
GOAL = 1

def water_jug_bfs():
    start = (0, 0)
    visited = set()
    queue = deque([[start]])

    while queue:
        path = queue.popleft()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                queue.append(new_path)
    return None

solution = water_jug_bfs()
print("BFS Solution path:")
for step in solution:
    print(step)

"""2. Depth-First Search (DFS)

* DFS explores as far as possible along one path before backtracking.

* Memory efficient, uses stack (linear with depth).

* Does not guarantee shortest path, can get stuck exploring long or irrelevant paths.

* Best for: when memory is limited and finding a solution (not necessarily the best one) is acceptable.
"""

def water_jug_dfs():
    start = (0, 0)
    stack = [[start]]
    visited = set()

    while stack:
        path = stack.pop()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                stack.append(new_path)
    return None

solution = water_jug_dfs()
print("DFS Solution path:")
for step in solution:
    print(step)

"""3. A Search*

* A* is an informed search that uses both cost so far (g) and heuristic (h) to guide the search.

* Usually more efficient than BFS, finds shortest path faster.

* Guarantees optimal solution if heuristic is admissible (never overestimates).

* Requires more computation for heuristic and extra memory for storing costs.

* Best for: when heuristic is available and problem size is large.
"""

import heapq

def heuristic(state):
    x, y = state
    return min(abs(x - GOAL), abs(y - GOAL))

def a_star_water_jug():
    start = (0, 0)
    open_list = []
    heapq.heappush(open_list, (heuristic(start), 0, [start]))
    visited = {}

    while open_list:
        f, g, path = heapq.heappop(open_list)
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited and visited[state] <= g:
            continue
        visited[state] = g

        x, y = state
        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited or g + 1 < visited.get(nxt, float('inf')):
                new_path = list(path)
                new_path.append(nxt)
                new_g = g + 1
                new_f = new_g + heuristic(nxt)
                heapq.heappush(open_list, (new_f, new_g, new_path))

solution = a_star_water_jug()
print("A* Solution path:")
for step in solution:
    print(step)

"""# Reflection Questions:
1. Compare the solution paths found by BFS, DFS, and A*.
2. Which algorithm gives the shortest path? Why?
3. Which algorithm is more efficient in terms of time and memory?
# Answer:
| Algorithm | Description | Pros | Cons |
|-----------|-------------|------|------|
| **BFS (Breadth-First Search)** | Explores state space level by level until goal is found. | Guarantees shortest path; simple to implement. | High memory usage; slow for large problems. |
| **DFS (Depth-First Search)** | Explores one path fully before backtracking. | Memory efficient; simple to code. | Does not guarantee shortest path; may explore long/irrelevant paths. |
| **A\*** (A-star Search) | Uses cost `g` + heuristic `h` to guide search toward goal. | Finds shortest path efficiently; reduces unnecessary exploration. | Needs good heuristic; higher memory usage than DFS. |

"""