# -*- coding: utf-8 -*-
"""Repo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gYC8CNJm-No7oJtt9i_wDpP89QNNqavD

# A* (Heuristic Algorithm) *

ğŸ—ºï¸ The Graph

We model a weighted graph where each city is a node, and edges are the road distances (in km):

1. Berlin â†’ Leipzig (190 km), Berlin â†’ Prague (350 km)

2. Leipzig â†’ Munich (430 km)

3. Prague â†’ Vienna (330 km)

4. Munich â†’ Zurich (310 km)

5. Vienna â†’ Zurich (680 km)

ğŸ¯ Heuristic

We give each city an estimated straight-line distance to Zurich:

1. Berlin â†’ 650

2. Leipzig â†’ 500

3. Prague â†’ 600

4. Munich â†’ 310

5. Vienna â†’ 680

6. Zurich â†’ 0

ğŸ‘‰ These values are admissible (they donâ€™t overestimate the real shortest path), so A* will still guarantee optimality.
"""

import heapq

import heapq

# Weighted graph: each city maps to a dict of neighbors with distances (km)
graph = {
    "Berlin": {"Leipzig": 190, "Prague": 350},
    "Leipzig": {"Berlin": 190, "Munich": 430},
    "Prague": {"Berlin": 350, "Vienna": 330},
    "Munich": {"Leipzig": 430, "Zurich": 310},
    "Vienna": {"Prague": 330, "Zurich": 680},
    "Zurich": {"Munich": 310, "Vienna": 680}
}

# Heuristic: straight-line (rough estimates to Zurich as goal)
heuristic = {
    "Berlin": 650,
    "Leipzig": 500,
    "Prague": 600,
    "Munich": 310,
    "Vienna": 680,
    "Zurich": 0
}

def a_star(graph, start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list, (heuristic[start], [start]))
    g_costs = {start: 0}
    closed_set = set()

    while open_list:
        f, path = heapq.heappop(open_list)
        node = path[-1]

        if node == goal:
            return path, g_costs[node]

        if node in closed_set:
            continue

        closed_set.add(node)

        for neighbor, cost in graph[node].items():
            tentative_g = g_costs[node] + cost

            if neighbor not in g_costs or tentative_g < g_costs[neighbor]:
                g_costs[neighbor] = tentative_g
                f_cost = tentative_g + heuristic.get(neighbor, float('inf'))
                new_path = path + [neighbor]
                heapq.heappush(open_list, (f_cost, new_path))

    return None, float('inf')


# Example run
if __name__ == "__main__":
    start_city = "Berlin"
    goal_city = "Zurich"
    path, cost = a_star(graph, start_city, goal_city, heuristic)
    print("A* path:", path)
    print("Total cost:", cost)

"""# âš™ï¸ How A* Works Here

1. Start = Berlin, Goal = Zurich

* Push Berlin with f = g + h = 0 + 650 = 650.
2. Expand Berlin

* Neighbors: Leipzig (g=190), Prague (g=350).

* f(Leipzig) = 190 + 500 = 690

* f(Prague) = 350 + 600 = 950

â†’ Priority queue = [(690, path to Leipzig), (950, path to Prague)]

3. Expand Leipzig (lowest f = 690)

* Neighbors: Munich.

* g(Munich) = 190 + 430 = 620

* f(Munich) = 620 + 310 = 930

â†’ Queue = [(930, path to Munich), (950, path to Prague)]

4. Expand Munich (lowest f = 930)

* Neighbor: Zurich.

* g(Zurich) = 620 + 310 = 930

* f(Zurich) = 930 + 0 = 930

â†’ Goal found! ğŸ‰

âœ… Final Result

* Path = ['Berlin', 'Leipzig', 'Munich', 'Zurich']

* Cost = 930 km

ğŸ’¡ Key Takeaways

* heapq ensures we always expand the node with the lowest f = g + h.

* g_costs keeps track of the shortest known distance to each node.

* heuristic helps A* guide the search towards Zurich, instead of exploring blindly.

If the heuristic were -1 or negative, Zurich could get prioritized wrongly, possibly breaking the optimality guarantee.
"""