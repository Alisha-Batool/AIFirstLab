# -*- coding: utf-8 -*-
"""Repo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gYC8CNJm-No7oJtt9i_wDpP89QNNqavD

# A* (Heuristic Algorithm) *

🗺️ The Graph

We model a weighted graph where each city is a node, and edges are the road distances (in km):

1. Berlin → Leipzig (190 km), Berlin → Prague (350 km)

2. Leipzig → Munich (430 km)

3. Prague → Vienna (330 km)

4. Munich → Zurich (310 km)

5. Vienna → Zurich (680 km)

🎯 Heuristic

We give each city an estimated straight-line distance to Zurich:

1. Berlin → 650

2. Leipzig → 500

3. Prague → 600

4. Munich → 310

5. Vienna → 680

6. Zurich → 0

👉 These values are admissible (they don’t overestimate the real shortest path), so A* will still guarantee optimality.
"""

import heapq

import heapq

# Weighted graph: each city maps to a dict of neighbors with distances (km)
graph = {
    "Berlin": {"Leipzig": 190, "Prague": 350},
    "Leipzig": {"Berlin": 190, "Munich": 430},
    "Prague": {"Berlin": 350, "Vienna": 330},
    "Munich": {"Leipzig": 430, "Zurich": 310},
    "Vienna": {"Prague": 330, "Zurich": 680},
    "Zurich": {"Munich": 310, "Vienna": 680}
}

# Heuristic: straight-line (rough estimates to Zurich as goal)
heuristic = {
    "Berlin": 650,
    "Leipzig": 500,
    "Prague": 600,
    "Munich": 310,
    "Vienna": 680,
    "Zurich": 0
}

def a_star(graph, start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list, (heuristic[start], [start]))
    g_costs = {start: 0}
    closed_set = set()

    while open_list:
        f, path = heapq.heappop(open_list)
        node = path[-1]

        if node == goal:
            return path, g_costs[node]

        if node in closed_set:
            continue

        closed_set.add(node)

        for neighbor, cost in graph[node].items():
            tentative_g = g_costs[node] + cost

            if neighbor not in g_costs or tentative_g < g_costs[neighbor]:
                g_costs[neighbor] = tentative_g
                f_cost = tentative_g + heuristic.get(neighbor, float('inf'))
                new_path = path + [neighbor]
                heapq.heappush(open_list, (f_cost, new_path))

    return None, float('inf')


# Example run
if __name__ == "__main__":
    start_city = "Berlin"
    goal_city = "Zurich"
    path, cost = a_star(graph, start_city, goal_city, heuristic)
    print("A* path:", path)
    print("Total cost:", cost)

"""# ⚙️ How A* Works Here

1. Start = Berlin, Goal = Zurich

* Push Berlin with f = g + h = 0 + 650 = 650.
2. Expand Berlin

* Neighbors: Leipzig (g=190), Prague (g=350).

* f(Leipzig) = 190 + 500 = 690

* f(Prague) = 350 + 600 = 950

→ Priority queue = [(690, path to Leipzig), (950, path to Prague)]

3. Expand Leipzig (lowest f = 690)

* Neighbors: Munich.

* g(Munich) = 190 + 430 = 620

* f(Munich) = 620 + 310 = 930

→ Queue = [(930, path to Munich), (950, path to Prague)]

4. Expand Munich (lowest f = 930)

* Neighbor: Zurich.

* g(Zurich) = 620 + 310 = 930

* f(Zurich) = 930 + 0 = 930

→ Goal found! 🎉

✅ Final Result

* Path = ['Berlin', 'Leipzig', 'Munich', 'Zurich']

* Cost = 930 km

💡 Key Takeaways

* heapq ensures we always expand the node with the lowest f = g + h.

* g_costs keeps track of the shortest known distance to each node.

* heuristic helps A* guide the search towards Zurich, instead of exploring blindly.

If the heuristic were -1 or negative, Zurich could get prioritized wrongly, possibly breaking the optimality guarantee.
"""