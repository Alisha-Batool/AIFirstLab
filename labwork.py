# -*- coding: utf-8 -*-
"""LabWork.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rk8NwT5Pxi0kCj3CbWOEL4KoQoqNxlHj

COMSATS University Islamabad - Abbottabad Campus\
Artificial Intelligence - Lab Assignment #1 \
Alisha Batool \
SP23-BSE-149 \
https://github.com/Alisha-Batool/AIFirstLab/blob/9b877da9b14468b8e0a939ec0263d618e41b7712/YoutubeLink
"""

# Import deque from collections (for efficient queue operations)
from collections import deque

# Define a simple graph using a dictionary (Adjacency List)
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

# ---------- BFS FUNCTION ----------
def bfs(graph, start):
    visited = []                 # To keep track of visited nodes
    queue = deque([start])       # Initialize a queue with the starting node

    # Continue until the queue is empty
    while queue:
        node = queue.popleft()   # Remove the first element (FIFO)
        if node not in visited:  # Check if the node was not visited
            visited.append(node) # Mark it as visited
            queue.extend(graph[node])  # Add all connected nodes to the queue
    return visited

# ---------- DFS FUNCTION ----------
def dfs(graph, start, visited=None):
    if visited is None:
        visited = []             # Create an empty list for first call
    visited.append(start)        # Mark the current node as visited
    for neighbor in graph[start]: # Visit all adjacent nodes recursively
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

# ---------- PRINT RESULTS ----------
print("BFS Traversal:", bfs(graph, 'A'))
print("DFS Traversal:", dfs(graph, 'A'))

# Create a dictionary to store student information
student = {
    "name": "Alisha",
    "age": 21,
    "roll_number": "BSSE123",
    "grade": "A"
}

# 1. Print all keys and values
print("All Keys:", student.keys())
print("All Values:", student.values())

# 2. Update the grade of the student
student["grade"] = "A+"

# 3. Add a new key 'email' with a value
student["email"] = "alisha@example.com"

# 4. Delete the 'roll_number' key
del student["roll_number"]

# Print final dictionary
print("\nUpdated Student Information:")
print(student)

# 1. Import the Matplotlib library
import matplotlib.pyplot as plt

# 2. Create a simple line plot
X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]   # Example data (you can choose any values)

plt.plot(X, Y, marker='o', color='blue')
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.grid(True)
plt.show()

from collections import deque
import time

# Define the capacities of the two jugs and the goal amount
jug1, jug2, goal = 4, 3, 2

# ---------- BFS Implementation ----------
def bfs_water_jug():
    start = (0, 0)                 # Starting state (both jugs empty)
    visited = set([start])         # Keep track of visited states
    queue = deque([(start, [])])   # Queue holds (state, path)

    while queue:
        (a, b), path = queue.popleft()
        if a == goal or b == goal: # Goal test
            return path + [(a, b)]

        # Generate all possible next states
        next_states = [
            (jug1, b),             # Fill jug1
            (a, jug2),             # Fill jug2
            (0, b),                # Empty jug1
            (a, 0),                # Empty jug2
            (a - min(a, jug2 - b), b + min(a, jug2 - b)), # Pour jug1 -> jug2
            (a + min(b, jug1 - a), b - min(b, jug1 - a))  # Pour jug2 -> jug1
        ]

        # Enqueue all unvisited states
        for state in next_states:
            if state not in visited:
                visited.add(state)
                queue.append((state, path + [(a, b)]))
    return None

# ---------- DFS Implementation ----------
def dfs_water_jug():
    stack = [(0, 0, [])]           # Stack holds (jug1, jug2, path)
    visited = set()

    while stack:
        a, b, path = stack.pop()
        if (a, b) in visited:
            continue
        visited.add((a, b))

        if a == goal or b == goal:
            return path + [(a, b)]

        next_states = [
            (jug1, b),
            (a, jug2),
            (0, b),
            (a, 0),
            (a - min(a, jug2 - b), b + min(a, jug2 - b)),
            (a + min(b, jug1 - a), b - min(b, jug1 - a))
        ]

        for state in next_states:
            if state not in visited:
                stack.append((*state, path + [(a, b)]))
    return None

# ---------- Compare BFS and DFS ----------
start_time = time.time()
bfs_path = bfs_water_jug()
bfs_time = time.time() - start_time

start_time = time.time()
dfs_path = dfs_water_jug()
dfs_time = time.time() - start_time

# Display results
print("BFS Solution Path:", bfs_path)
print("DFS Solution Path:", dfs_path)
print(f"BFS Time: {bfs_time:.6f} seconds")
print(f"DFS Time: {dfs_time:.6f} seconds")

from heapq import heappush, heappop

# Maze Layout (A = Start, Y = Goal, '#' = Wall, '.' = Empty Path)
maze = [
    ['A', '.', '.', '.', '.'],
    ['#', '#', '.', '#', '.'],
    ['.', '.', '.', '#', '.'],
    ['.', '#', '#', '.', '.'],
    ['.', '.', '.', '.', 'Y']
]

start, goal = (0, 0), (4, 4)  # Starting and goal coordinates

# Heuristic Function â€“ Manhattan Distance
def heuristic(a, b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])

# ---------- A* Algorithm ----------
def astar(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = []
    heappush(open_set, (0 + heuristic(start, goal), 0, start, [start]))  # (f, g, node, path)
    visited = set()

    while open_set:
        _, cost, current, path = heappop(open_set)

        if current == goal:
            return path  # Found the goal, return path

        if current in visited:
            continue
        visited.add(current)

        x, y = current

        # Explore all 4 possible directions (up, down, left, right)
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            nx, ny = x + dx, y + dy
            # Check if the new position is valid and not a wall
            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] != '#':
                new_cost = cost + 1
                heappush(open_set, (
                    new_cost + heuristic((nx, ny), goal),
                    new_cost,
                    (nx, ny),
                    path + [(nx, ny)]
                ))
    return None  # No path found

# Run A* Search and print path
path = astar(maze, start, goal)
print("A* Search Path from A to Y:", path)
